Code in cellForRowAtIndexPath used to load UITableViewCell images. Switched out for AFNetworking cached image loading.

        // if the image data exists display it immediately. if not, add a block off the main queue to go grab and store it.
        /*
        if (article.actualImage != nil) {
            image.image = article.actualImage;
        }
        else {
            NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:article.imageURL]];
            NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
            NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
            NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL *localfile, NSURLResponse *response, NSError *error) {
                if (!error) {
                    //NSLog(@"request.URL: %@", [request.URL absoluteString]);
                    //NSLog(@"photo.thumbnailURL: %@", photo.thumbnailURL);
                    article.actualImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:localfile]];
                }
                else {
                    NSLog(@"Image download failed: %@", error.localizedDescription);
                }
            }];
            [task resume];
        }
         */
        





Old didSelectRowAtIndexPath --

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    // if the table view sending the message is the search controller TVC
    if (tableView == self.searchDisplayController.searchResultsTableView) {
        
        [tableView deselectRowAtIndexPath:indexPath animated:NO];
        [self.searchDisplayController setActive:NO animated:YES];
        
        NSDictionary *selectedSearchResult = (NSDictionary *)self.searchResults[indexPath.row];
        NSLog(@"selectedSearchResult: %@", [selectedSearchResult description]);
        
        NSString *placedID = [selectedSearchResult objectForKey:@"place_id"];
        NSString *url = [NSString stringWithFormat:@"https://maps.googleapis.com/maps/api/place/details/json?placeid=%@&key=%@", placedID, googleAPIKeyForBrowserApplications];
        NSLog(@"URL we're loading: %@", url);
        NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:url]];
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
        NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL *localFile, NSURLResponse *response, NSError *error) {
            if (!error) {
                NSDictionary *fetchedPlace;
                NSData *fetchedJSONData = [NSData dataWithContentsOfURL:localFile]; // will block if url is not local!
                if (fetchedJSONData) {
                    fetchedPlace = [NSJSONSerialization JSONObjectWithData:fetchedJSONData options:0 error:NULL];
                    NSLog(@"retrieved data: %@", fetchedPlace);
                }
                NSLog(@"place: %@", fetchedPlace);
                
                // create the coordinate structure with the returned JSON
                CLLocationCoordinate2D selectedLocation = CLLocationCoordinate2DMake([[fetchedPlace valueForKeyPath:@"result.geometry.location.lat"] doubleValue], [[fetchedPlace valueForKeyPath:@"result.geometry.location.lng"] doubleValue]);
                
                // store it in an instance variable
                [self setLocationWithLatitude:selectedLocation.latitude andLongitude:selectedLocation.longitude];
                
                // on the main queue, update the map to that coordinate
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self.mapView moveCamera:[GMSCameraUpdate setTarget:selectedLocation zoom:16.0]];
                    
                    GMSMarker *marker = [GMSMarker markerWithPosition:selectedLocation];
                    marker.snippet = @"Hello World";
                    marker.appearAnimation = kGMSMarkerAnimationPop;
                    marker.map = self.mapView;
                    
                    NSLog(@"Im on the main thread");
                });
            }
            else {
                NSLog(@"Fetch failed: %@", error.localizedDescription);
                NSLog(@"Fetch failed: %@", error.userInfo);
            }
        }];
        [task resume];
        
        /*
         
         NSString *formattedAddressString = [self prepareAddressString:selectedSearchResult withoutUS:YES];
         
         // create a new annotation in order to set title and subtitle how we want. using MKPlacemark as the annotation doesn't permit that flexibility.
         MKPointAnnotation *annotation2 = [[MKPointAnnotation alloc] init];
         annotation2.title = selectedSearchResult.name;
         annotation2.subtitle = formattedAddressString;
         [annotation2 setCoordinate:selectedSearchResult.coordinate];
         
         self.searchDisplayController.searchBar.text = formattedAddressString;
         
         // clear existing annotations and add our new one.
         [self.mapView removeAnnotations:[self.mapView annotations]];
         [self.mapView addAnnotation:annotation2];
         [self.mapView showAnnotations:[self.mapView annotations] animated:YES];
         */
        
    }
}










Executing the Google Places search using native SDK --

/*
    NSString *encodedSearchString = [searchString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    NSString *url = [NSString stringWithFormat:@"https://maps.googleapis.com/maps/api/place/autocomplete/json?input=%@&location=%f,%f&radius=%@&sensor=true&key=%@", encodedSearchString, locationToSearchAround.latitude, locationToSearchAround.longitude, [NSString stringWithFormat:@"%i", 10000], googleAPIKeyForBrowserApplications];
    NSLog(@"URL we're loading: %@", url);
    NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:url]];
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
    NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL *localFile, NSURLResponse *response, NSError *error) {
        if (!error) {
            NSDictionary *fetchedPlacesList;
            NSData *fetchedJSONData = [NSData dataWithContentsOfURL:localFile]; // will block if url is not local!
            if (fetchedJSONData) {
                fetchedPlacesList = [NSJSONSerialization JSONObjectWithData:fetchedJSONData options:0 error:NULL];
                NSLog(@"retrieved data: %@", fetchedPlacesList);
            }
            NSArray *places = [fetchedPlacesList valueForKeyPath:@"predictions"];
            NSLog(@"places: %@", places);
            self.searchResults = places;
        }
        else {
            NSLog(@"Fetch failed: %@", error.localizedDescription);
            NSLog(@"Fetch failed: %@", error.userInfo);
        }
    }];
    [task resume];
*/





/*

HoodieTableViewCell.xib

HoodieTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"HoodieTableViewCell"];
if (cell == nil) {
// Load the top-level objects from the custom cell XIB.
NSArray *topLevelObjects = [[NSBundle mainBundle] loadNibNamed:@"HoodieTableViewCell" owner:self options:nil];
// Grab a pointer to the first object (presumably the custom cell, as that's all the XIB should contain).
cell = [topLevelObjects objectAtIndex:0];
}
cell.imageContainerView.backgroundColor = [UIColor redColor];

MappedContent *itemToDisplay = (MappedContent *)self.articles[indexPath.row];
cell.textBox.text = itemToDisplay.title;
cell.leftUpperLabel.text = itemToDisplay.subtitle;

// if the image data exists display it immediately. if not, add a block off the main queue to go grab and store it.
if (itemToDisplay.actualImage != nil) {
cell.imageContainerView.image = itemToDisplay.actualImage;
}
else {
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:itemToDisplay.largeURL]];
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request
completionHandler:^(NSURL *localfile, NSURLResponse *response, NSError *error) {
if (!error) {
//NSLog(@"request.URL: %@", [request.URL absoluteString]);
//NSLog(@"photo.thumbnailURL: %@", photo.thumbnailURL);
itemToDisplay.actualImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:localfile]];
}
}];
[task resume];
}
return cell;
*/


/*

ArticleTableViewCell.xib

ArticleTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"ArticleTableViewCell"];
if (cell == nil) {
// Load the top-level objects from the custom cell XIB.
NSArray *topLevelObjects = [[NSBundle mainBundle] loadNibNamed:@"ArticleTableViewCell" owner:self options:nil];
// Grab a pointer to the first object (presumably the custom cell, as that's all the XIB should contain).
cell = [topLevelObjects objectAtIndex:0];
}
cell.articleImageView.backgroundColor = [UIColor redColor];

Article *article = (Article *)self.articles[indexPath.row];
cell.articleHeadline.text = article.title;
cell.articleCopy.text = article.introduction;
cell.articleMetaInfo.text = article.publication;

// if the image data exists display it immediately. if not, add a block off the main queue to go grab and store it.
if (article.actualImage != nil) {
cell.articleImageView.image = article.actualImage;
}
else {
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:article.imageURL]];
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL *localfile, NSURLResponse *response, NSError *error) {
if (!error) {
//NSLog(@"request.URL: %@", [request.URL absoluteString]);
//NSLog(@"photo.thumbnailURL: %@", photo.thumbnailURL);
article.actualImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:localfile]];
}
else {
NSLog(@"Image download failed: %@", error.localizedDescription);
}
}];
[task resume];
}
return cell;
*/



/*

WORKING

static NSString *customTableCell = @"Hoodie Cell";
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:customTableCell forIndexPath:indexPath];
MappedContent *itemToDisplay = (MappedContent *)self.articles[indexPath.row];
cell.textLabel.text = itemToDisplay.title;
cell.detailTextLabel.text = [NSString stringWithFormat:@"Current row: %ld", (long)indexPath.row];
return cell;
*/

